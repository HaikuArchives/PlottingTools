/* ------------------------------------------------------------------ 	Title: 		LMSmoothingFilters	Description: 		A set of digital signal filters	Author :		Stephen Wardlaw, M.D.		Yale University School of Medicine		20 York St.		New Haven, CT  06504	Edit History:				11 March, 1995			Created------------------------------------------------------------------ */ #include "LMSmoothingFilters.h"#include "LMProbits.h"//#include <math.h>//#include <UException.h>//const double two_pi = 3.14159*2;// ------------------------------------------------------------------ //	¥ CONSTRUCTORS & DESTRUCTOR// ------------------------------------------------------------------ LMSmoothingFilters::LMSmoothingFilters(){}	LMSmoothingFilters::~LMSmoothingFilters(){}// ------------------------------------------------------------------ //	¥ Public Methods// ------------------------------------------------------------------ // Smooth the array 'dArray'voidLMSmoothingFilters::AverageData(double* dArray, int aryLen, int span){	int 		halfSpan = span/2;	int		n, lhsIndx, rhsIndx;	// double	rn1, y0, yn;	double	tVal;		double* lhsHold = new double[halfSpan];	double* rhsHold = new double[halfSpan];	/*	// Remove any constant slope factor	y0 = dArray[0];	yn = dArray[aryLen - 1];	rn1 = 1.0/(aryLen - 1.0);	for (n = 0; n < aryLen; n++) {		dArray[n] = dArray[n] - rn1*(y0*(aryLen - n - 1) + yn*n);	}	*/	// Load the holding array and calculate the starting sum	double 	sum = dArray[0];	lhsIndx = halfSpan - 1;	rhsIndx = 0;	for(n = 0; n < halfSpan; n++) {		lhsHold[lhsIndx] = dArray[0] + (dArray[0] - dArray[n + 1]);		rhsHold[rhsIndx] = dArray[aryLen - 1] + (dArray[aryLen - 1] - dArray[aryLen - n - 2]);		sum += lhsHold[lhsIndx] + dArray[n + 1];		lhsIndx--;		rhsIndx++;	}		// Average the array up to the end of the span	lhsIndx = 0;	span = halfSpan*2 + 1;  // Ensure an odd total span length	for(n = 0; n < (aryLen - halfSpan - 1); n++) {		tVal = dArray[n];		dArray[n] = sum/span;		sum -= lhsHold[lhsIndx];		lhsHold[lhsIndx] = tVal;		sum += dArray[n + halfSpan + 1];		lhsIndx = ++lhsIndx % halfSpan;	}		// Average the end of the array	rhsIndx = 0;	while(n < aryLen) {		tVal = dArray[n];		dArray[n] = sum/span;		sum -= lhsHold[lhsIndx];		sum += rhsHold[rhsIndx];		lhsIndx = ++lhsIndx % halfSpan;		rhsIndx++;		n++;	}	/*	// Add back the constant slope factor	for(n = 0; n < aryLen; n++) {		dArray[n] = rn1*(y0*(aryLen - n - 1) + yn*n) + dArray[n];	}	*/	delete [] lhsHold;	delete [] rhsHold;}// ------------------------------------------------------------------ // Smooth the array 'sArray'voidLMSmoothingFilters::AverageData(short* sArray, int aryLen, int span){}// ------------------------------------------------------------------ void	LMSmoothingFilters::AverageData(const double* const sourceArray, 										  double* destArray, 										  int aryLen, int span){	if(span < 3) {		span = 3;	// Enforce a span of at least 3	}	int	n;	int halfSpan = span/2;	// Calculate the starting sum.  We use the sum of the first 'span' elements.	span = halfSpan*2 + 1; // Ensure an odd total span length	double 	sum = 0;	for(n = 0; n < span; n++) {		sum += sourceArray[n];	}		// Average the array up to the end of the span	for(n = halfSpan; n < (aryLen - halfSpan - 1); n++) {		destArray[n] = sum/span;		sum -= sourceArray[n - halfSpan];		sum += sourceArray[n + halfSpan];	}		// Fill the beginning and end of the array	n = halfSpan - 1;	while(n >= 0) {		destArray[n] = destArray[halfSpan];		n--;	}	n = aryLen - halfSpan;	while(n < aryLen) {		destArray[n] = destArray[aryLen - halfSpan - 1];		n++;	}}// ------------------------------------------------------------------ void	LMSmoothingFilters::AverageData(const short* const sourceArray, 										  short* destArray, 										  int aryLen, int span){			if(span < 3) {		span = 3;	// Enforce a span of at least 3	}	int	n;	int halfSpan = span/2;		// Calculate the starting sum.  We use the sum of the first 'span' elements.	span = halfSpan*2 + 1; // Ensure an odd total span length	double 	sum = 0;	for(n = 0; n < span; n++) {		sum += sourceArray[n];	}		// Average the array up to the end of the span	for(n = halfSpan; n < (aryLen - halfSpan - 1); n++) {		destArray[n] = sum/span;		sum -= sourceArray[n - halfSpan];		sum += sourceArray[n + halfSpan];	}		// Fill the beginning and end of the array	n = halfSpan - 1;	while(n >= 0) {		destArray[n] = destArray[halfSpan];		n--;	}	n = aryLen - halfSpan;	while(n < aryLen) {		destArray[n] = destArray[aryLen - halfSpan - 1];		n++;	}}	// ------------------------------------------------------------------ // Smooth the array 'dArray' through a gaussian filtervoidLMSmoothingFilters::GaussFilter(double* dArray, int aryLen, int span){	const double	p_span = 3.0;	// +/- 3SD range of clipping	span = (span/2);	double* lhsHold = new double[span];	double* rhsHold = new double[span];	double	pInt = p_span/(span + 0.5);	// Note that the 'span' is always odd	double*	gAry = new double[span*2 + 1];		// Holds the gaussian factors		// Calculate the distribution coefficients	LMProbits	probit;	double pStart = 5.0 - p_span;	// Start at 	double pVal = probit.XformFrom(pStart);	double pSum = 0;	for(int n = 0; n < span; n++) {		pStart += pInt;		gAry[n] = (probit.XformFrom(pStart) - pVal)*.01;		pVal = probit.XformFrom(pStart);		gAry[span*2 - n] = gAry[n];		pSum += gAry[n]*2;	}	gAry[span] = 1.0 - pSum;		// double	rn1, y0, yn;		/*	// Remove any constant slope factor	y0 = dArray[0];	yn = dArray[aryLen - 1];	rn1 = 1.0/(aryLen - 1.0);	for (n = 0; n < aryLen; n++) {		dArray[n] = dArray[n] - rn1*(y0*(aryLen - n - 1) + yn*n);	}	*/	// Load the holding array and calculate the starting sum	int lhsIndx = span - 1;	int rhsIndx = 0;	for(n = 0; n < span; n++) {		lhsHold[lhsIndx] = dArray[0] + (dArray[0] - dArray[n + 1]);		rhsHold[rhsIndx] = dArray[aryLen - 1] + (dArray[aryLen - 1] - dArray[aryLen - n - 2]);		lhsIndx--;		rhsIndx++;	}		// Average the array up to the end of the span	lhsIndx = 0;	double 	sum;	int gIndx;	for(n = 0; n < (aryLen - span); n++) {		sum = 0.0;		for(gIndx = 0; gIndx < span; gIndx++) {			sum += lhsHold[(gIndx + lhsIndx) % span]*gAry[gIndx];			sum += dArray[n + span - gIndx]*gAry[gIndx];		}		sum += dArray[n]*gAry[span];		lhsHold[lhsIndx] = dArray[n];		dArray[n] = sum;		lhsIndx = ++lhsIndx % span;	}	/*	// Average the end of the array	rhsIndx = 0;	while(n < aryLen) {		sum = 0.0;		for(gIndx = 0; gIndx < span; gIndx++) {			if((n + gIndx) >= aryLen) {				sum += rhsHold[gIndx]*gAry[gIndx];			} else {				sum += dArray[			sum += dArray[n + (span - gIndx)]*gAry[gIndx];		}		sum += dArray[n]*gAry[span];		dArray[n] = sum;		rhsIndx++;		n++;	}	*/	/*	// Add back the constant slope factor	for(n = 0; n < aryLen; n++) {		dArray[n] = rn1*(y0*(aryLen - n - 1) + yn*n) + dArray[n];	}	*/	delete [] lhsHold;	delete [] rhsHold;	delete [] gAry;}// ------------------------------------------------------------------ // Smooth the array 'sArray' through a gaussian filtervoidLMSmoothingFilters::GaussFilter(short* sArray, int aryLen, int span){}// ------------------------------------------------------------------ voidLMSmoothingFilters::GaussFilter(const double* const sourceArray, 										  double* destArray, 										  int aryLen, int span){	if(span < 3) {		span = 3;	// Enforce span of at least 3	}		int halfSpan = span/2;	span = halfSpan*2+1;	// Span is always odd	const double	p_span = 3.0;	// +/- 3SD range of clipping	double	pInt = p_span/(halfSpan + 0.5);	// Note that the 'span' is always odd	double*	gAry = new double[span];		// Holds the gaussian factors		// Calculate the distribution coefficients	LMProbits	probit;	double pStart = 5.0 - p_span;	// Start at 	double pVal = probit.XformFrom(pStart);	double pSum = 0;	for(int n = 0; n < halfSpan; n++) {		pStart += pInt;		gAry[n] = (probit.XformFrom(pStart) - pVal)*.01;		pVal = probit.XformFrom(pStart);		gAry[span - n] = gAry[n];		pSum += gAry[n]*2;	}	gAry[halfSpan] = 1.0 - pSum;	// Ensure total is always 1.0		// Average the array up to the end of the span	for(n = halfSpan; n < (aryLen - halfSpan - 1); n++) {		destArray[n] = 0;		for(int s = 0; s < span; s++) {			destArray[n] += sourceArray[s + n - halfSpan]*gAry[s];		}	}	// Fill the beginning and end of the array	n = halfSpan - 1;	while(n >= 0) {		destArray[n] = destArray[halfSpan];		n--;	}	n = aryLen - halfSpan;	while(n < aryLen) {		destArray[n] = destArray[aryLen - halfSpan - 1];		n++;	}	delete [] gAry;}		// ------------------------------------------------------------------ voidLMSmoothingFilters::GaussFilter(const short* const sourceArray, 										  short* destArray, 										  int aryLen, int span){}		// ------------------------------------------------------------------ //	¥ Protected Methods// ------------------------------------------------------------------ 